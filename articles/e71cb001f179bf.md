---
title: "æŒ¯ã‚‹èˆã„ã«å¿œã˜ã¦å‹ã‚’åˆ†ã‘ã‚‹ã“ã¨ã§è¤‡é›‘ã•ã«å¯¾å‡¦ã™ã‚‹"
emoji: "ğŸ›¡ï¸"
type: "tech" # tech: æŠ€è¡“è¨˜äº‹ / idea: ã‚¢ã‚¤ãƒ‡ã‚¢
topics: [ãƒ‰ãƒ¡ã‚¤ãƒ³é§†å‹•è¨­è¨ˆ, ddd, typescript]
published: true
published_at: 2023-12-01 10:00
---

# ã‚¢ãƒ‰ãƒ™ãƒ³ãƒˆã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼ 1 æ—¥ç›®

æœ¬è¨˜äº‹ã¯[LabBase ãƒ†ãƒƒã‚¯ã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼ Advent Calendar 2023](https://qiita.com/advent-calendar/2023/labbase) 1 æ—¥ç›®ã§ã™ã€‚

# ã¯ã˜ã‚ã«

å‰å›ã®è¨˜äº‹ã§ã¯[Domain Modeling Made Functional: Tackle Software Complexity with Domain-Driven Design and F#](https://www.amazon.co.jp/-/en/Scott-Wlaschin/dp/1680502549) ã®èª­æ›¸ãƒ¡ãƒ¢ã‚’ã¾ã¨ã‚ã¾ã—ãŸã€‚
https://zenn.dev/labbase/articles/b1c513c32fe15e

[Domain Modeling Made Functional: Tackle Software Complexity with Domain-Driven Design and F#](https://www.amazon.co.jp/-/en/Scott-Wlaschin/dp/1680502549) ã‚„ã€[@kawasima](https://twitter.com/kawasima) ã•ã‚“ã®è¨˜äº‹ã‚’èª­ã‚“ã§ã€æŒ¯ã‚‹èˆã„ã«å¿œã˜ã¦å‹ã‚’åˆ†ã‘ã‚‹ã“ã¨ã§è¤‡é›‘ã•ã«å¯¾å‡¦ã™ã‚‹æ–¹æ³•ã‚’å®Ÿè·µã—ã¦ã¿ãŸã„ã¨æ€ã„ã¾ã—ãŸã€‚

ãã“ã§ã€TypeScript ã§ç°¡å˜ãªã‚¿ã‚¹ã‚¯ç®¡ç†ã‚¢ãƒ—ãƒªã® API ã‚’ä½œã£ã¦ã¿ã¾ã—ãŸã€‚

æ—¢å­˜ã®ã‚µãƒ³ãƒ—ãƒ«ã‚³ãƒ¼ãƒ‰ã«ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã¨ã®æ¥ç¶šéƒ¨åˆ†ã«é–¢ã™ã‚‹å®Ÿè£…ãŒå«ã¾ã‚Œã¦ã„ã‚‹ã“ã¨ãŒå°‘ãªã‹ã£ãŸã®ã§ã€æ„Ÿè§¦ã‚’å¾—ãŸã„ã¨ã„ã†ã®ãŒä¸»ãªç›®çš„ã§ã™ã€‚

å®Ÿè£…ã—ãŸã‚³ãƒ¼ãƒ‰ã¯ã“ã¡ã‚‰ã§ã™ã€‚

https://github.com/motikoma/task-management-app

# ã‚„ã‚‰ãªã‹ã£ãŸã“ã¨

ä»Šå›ã®ç›®çš„ã¨ç•°ãªã‚‹ã®ã§é–¢æ•°å‹ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°ã®ãƒ†ã‚¯ãƒ‹ãƒƒã‚¯ã‚’é§†ä½¿ã—ã¦ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã‚’æ§‹æˆã™ã‚‹ã‚¢ãƒ—ãƒ­ãƒ¼ãƒã¯æ¡ç”¨ã—ã¾ã›ã‚“ã§ã—ãŸã€‚ã¾ãŸã€ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ã«ã¤ã„ã¦ã‚‚é›‘ã§ã™ã€‚ãƒ†ã‚¹ãƒˆã‚‚æ›¸ã„ã¦ã¾ã›ã‚“ã€‚ä½™åŠ›ãŒã‚ã‚Œã°æ¬¡å›ä»¥é™ã§ãƒˆãƒ©ã‚¤ã—ã¦ã¿ãŸã„ã¨æ€ã„ã¾ã™ã€‚

# ã‚¤ãƒ™ãƒ³ãƒˆã‚¹ãƒˆãƒ¼ãƒŸãƒ³ã‚°

https://qiita.com/little_hand_s/items/69ccbb9915d75ad09ad5
https://scrapbox.io/kawasima/%E3%83%89%E3%83%A1%E3%82%A4%E3%83%B3%E3%83%A2%E3%83%87%E3%83%AB%E8%B2%A7%E8%A1%80%E7%97%87

ä¸Šè¨˜ã®è¨˜äº‹ã‚’å‚è€ƒã« ã‚¿ã‚¹ã‚¯ç®¡ç†ã‚¢ãƒ—ãƒªã‚’é¡Œæã¨ã—ã¦ãƒ‰ãƒ¡ã‚¤ãƒ³ãƒ¢ãƒ‡ãƒªãƒ³ã‚°ã‚’ã—ã¦ã¿ã¾ã™ã€‚è¦ä»¶ã¯ä¸‹è¨˜ã®é€šã‚Šã§ã™ã€‚

- ã‚¿ã‚¹ã‚¯ã¯å¿…ãšã‚¿ã‚¹ã‚¯åã€æœŸæ—¥ã‚’æŒã¤
- ã‚¿ã‚¹ã‚¯ã¯æœªå®Œäº†çŠ¶æ…‹ã§ä½œæˆã—ã€å®Œäº†ã—ãŸã‚‰æˆ»ã™ã“ã¨ã¯ã§ããªã„
- ã‚¿ã‚¹ã‚¯ã¯ 3 å›ã ã‘ã€1 æ—¥ãšã¤å»¶æœŸã™ã‚‹ã“ã¨ãŒã§ãã‚‹
- ã‚¿ã‚¹ã‚¯åã¯å¤‰æ›´ã™ã‚‹ã“ã¨ãŒã§ããªã„

ã‚¤ãƒ™ãƒ³ãƒˆã‚¹ãƒˆãƒ¼ãƒŸãƒ³ã‚°ã‚’ã»ã‚“ã®ã•ã‚ã‚Šã ã‘è©¦ã—ã¦ã¿ã¾ã—ãŸã€‚
![](https://storage.googleapis.com/zenn-user-upload/f91930e7ddb9-20231029.png)

ã‚¤ãƒ™ãƒ³ãƒˆã‚¹ãƒˆãƒ¼ãƒŸãƒ³ã‚°ã®é€²ã‚æ–¹ã¯ã“ã¡ã‚‰ã‚’å‚è€ƒã«ã—ã¾ã—ãŸã€‚
https://www.youtube.com/watch?v=jC9lE4YqgyY

### æ‰€æ„Ÿ

- ã€Œã‚¿ã‚¹ã‚¯ã®æœŸé™ã‚’éããŸã€ãªã©å½“åˆè€ƒãˆã¦ã„ãªã‹ã£ãŸã‚¤ãƒ™ãƒ³ãƒˆãŒå‡ºã¦ãã¾ã—ãŸã€‚ã‚¿ã‚¹ã‚¯ã®æœŸé™ã‚’éããŸæ™‚ã¯ã©ã†ã—ã¾ã—ã‚‡ã†ã‹ï¼Ÿé€šçŸ¥ã‚’é£›ã°ã™å¿…è¦ãŒã‚ã‚Šã¾ã™ã‹ã­ï¼Ÿ
- è¤‡æ•°äººã§ã‚„ã‚‹ã¨ã€éš ã‚Œã¦ã„ãŸã‚¤ãƒ™ãƒ³ãƒˆã‚’ç¶²ç¾…çš„ã«ç™ºè¦‹ã§ããã†ã§ã™ã€‚
- æœ¬å½“ã¯ã‚‚ã£ã¨è‰²ã€…å‡ºã¦ãã‚‹ã¨æ€ã†ã®ã§ã™ãŒã€ä»Šå›ã¯ã‚¹ã‚³ãƒ¼ãƒ—ã‚’é–‰ã˜ã¦ãŠããŸã„ã®ã§æ·±å €ã‚Šã—ã¦ã„ã¾ã›ã‚“ã€‚

# ãƒ‰ãƒ¡ã‚¤ãƒ³ã®æ–‡æ›¸åŒ–

```
ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆ: TaskManagement

- ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼: post
  - å…¥åŠ›: UnvalidatedTask
  - å‡ºåŠ›: PostponableUnDoneTask

- ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼: postpone
  - å…¥åŠ›ï¼šPostponableUnDoneTask
  - å‡ºåŠ›ï¼šPostponableUnDoneTask | UndoneTaskWithDeadline
  - ãƒ«ãƒ¼ãƒ«ï¼šã‚¿ã‚¹ã‚¯ã¯ 3 å›ã ã‘ã€1 æ—¥ãšã¤å»¶æœŸã™ã‚‹ã“ã¨ãŒã§ãã‚‹

- ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼: complete
  - å…¥åŠ›: UnDoneTask
  - å‡ºåŠ›: DoneTask
```

### æ‰€æ„Ÿ

- ã€ŒDomain Modeling Made Functionalã€ã§ã¯å…¥åŠ›ã‚¤ãƒ™ãƒ³ãƒˆã¨å…¥åŠ›å€¤ã‚’åˆ†ã‘ã¦ã„ã¾ã—ãŸãŒã€åˆ†ã‘ãŸæ–¹ãŒã„ã„ã®ã§ã—ã‚‡ã†ã‹ï¼Ÿã„ã¾ã„ã¡ãƒ”ãƒ³ã¨ãã¦ã¾ã›ã‚“ã€‚
- ãƒ‡ãƒ¼ã‚¿ã«é–¢ã—ã¦ã¯å‹ã§è¡¨ç¾ã—ã¦ã‚‚éã‚¨ãƒ³ã‚¸ãƒ‹ã‚¢ã«ä¼ã‚ã‚‹ã¨æ€ã£ãŸã®ã§ãã†ã—ã¦ã¾ã™ã€‚
- ã‚¯ãƒ©ã‚¹ã§æ›¸ã„ãŸå ´åˆã¨æ¯”è¼ƒã—ã¦ã€è¦ä»¶ãŒå®ˆã‚‰ã‚Œã‚„ã™ã„ã‹ã©ã†ã‹ã‚’æƒ³åƒã—ã¦ã¿ãŸã®ã§ã™ãŒã€ã‚ã¾ã‚Šå¤‰ã‚ã‚‰ãªã„æ°—ãŒã—ã¾ã™ã€‚

# å®Ÿè£…

## ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£

ã‚ªãƒ‹ã‚ªãƒ³ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£ã‚’æ¡ç”¨ã—ã¦å®Ÿè£…ã—ã¦ã„ã¾ã™ã€‚IoC ã‚³ãƒ³ãƒ†ãƒŠã‚’ä½¿ç”¨ã—ãªã„ã®ã§ä¾å­˜ã®å‘ãã¯é€†è»¢ã—ã¦ã„ã¾ã›ã‚“ã€‚ãŸã ã—ã€Domain å±¤ã¯ä»–ã®å±¤ã«ä¾å­˜ã—ã¦ã„ã¾ã›ã‚“ã€‚

![](https://storage.googleapis.com/zenn-user-upload/e73137d20fe5-20231028.png)

### æ‰€æ„Ÿ

- ã€ŒDomain Modeling Made Functionalã€ã§ã¯ã‚ªãƒ‹ã‚ªãƒ³ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£ãŒæç¤ºã•ã‚Œã¦ã„ã¾ã—ãŸã€‚ã‚µãƒ³ãƒ—ãƒ«ã‚³ãƒ¼ãƒ‰ã¯ä¸‹è¨˜ã®ã‚ˆã†ã«ãªã£ã¦ãŠã‚Šã€ãƒ¬ã‚¤ãƒ¤ãƒ¼ã”ã¨ã«ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªãŒåˆ†ã‹ã‚Œã‚‹å½¢ã«ã¯ãªã£ã¦ã„ã¾ã›ã‚“ã€‚
  - https://github.com/swlaschin/DomainModelingMadeFunctional/tree/master/src/OrderTakingEvolved
- ä»Šå›ã¯ãƒ¬ã‚¤ãƒ¤ãƒ¼ã”ã¨ã«ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã‚’åˆ†ã‘ã¦ã¿ã¾ã—ãŸã€‚ãƒ¬ã‚¤ãƒ¤ãƒ¼é–“ã®ä¾å­˜é–¢ä¿‚ãŒæ˜ç¢ºã«ãªã‚Šã€ä¾å­˜é–¢ä¿‚ã‚’ç®¡ç†ã—ã‚„ã™ããªã‚‹ã¨æ€ã„ã¾ã—ãŸãŒã©ã†ã§ã—ã‚‡ã†ã‹ï¼Ÿ

## ãƒ‰ãƒ¡ã‚¤ãƒ³å±¤

```
import { z } from "zod";

/**
 * ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼
 */

export type Command = {
  id: string;
  isDone: boolean;
  name: string;
  dueDate: Date;
  postPoneCount: number;
};
export type Post = (command: Command) => PostPonableUnDoneTask;
export const post: Post = (command: Command) => {
  return PostPonableUnDoneTask.parse({
    kind: POSTPONABLE_UNDONE_TASK,
    id: command.id,
    name: command.name,
    dueDate: command.dueDate,
    postPoneCount: command.postPoneCount,
  });
};

export type Postpone = (task: PostPonableUnDoneTask) => UnDoneTask;
export const postpone: Postpone = (task: PostPonableUnDoneTask) => {
  const newDueDate = new Date(task.dueDate);
  newDueDate.setDate(newDueDate.getDate() + 1);

  if (task.postPoneCount === 2) {
    return UnDoneTaskWithDeadline.parse({
      kind: "UnDoneTaskWithDeadline",
      id: TaskId.parse(task.id),
      name: task.name,
      dueDate: newDueDate,
      postPoneCount: task.postPoneCount + 1,
    });
  } else {
    return PostPonableUnDoneTask.parse({
      kind: "PostPonableUnDoneTask",
      id: TaskId.parse(task.id),
      name: task.name,
      dueDate: newDueDate,
      postPoneCount: task.postPoneCount + 1,
    });
  }
};

export type Complete = (task: UnDoneTask) => DoneTask;
export const complete: Complete = (task: UnDoneTask): DoneTask => {
  return DoneTask.parse({
    kind: "DoneTask",
    id: TaskId.parse(task.id),
    name: task.name,
    dueDate: task.dueDate,
  });
};

/**
 * ãƒªãƒã‚¸ãƒˆãƒª
 */
export type PostTaskRepository = (
  postPonableUnDoneTask: PostPonableUnDoneTask
) => Promise<PostPonableUnDoneTask>;
export type CompleteTaskRepository = (doneTask: DoneTask) => Promise<DoneTask>;
export type PostPoneTaskRepository = (
  UnDoneTask: UnDoneTask
) => Promise<UnDoneTask>;

/**
 * ãƒ‡ãƒ¼ã‚¿æ§‹é€ 
 */
export const TaskId = z.string().uuid().brand("TaskId");
export type TaskId = z.infer<typeof TaskId>;

export const TaskName = z.string().min(1).max(50);
export type TaskName = z.infer<typeof TaskName>;

export const POSTPONABLE_UNDONE_TASK = "PostPonableUnDoneTask";
export const PostPonableUnDoneTask = z.object({
  kind: z.literal(POSTPONABLE_UNDONE_TASK),
  id: TaskId,
  name: z.string(),
  dueDate: z.date(),
  postPoneCount: z.number().min(0).max(2),
});
export type PostPonableUnDoneTask = z.infer<typeof PostPonableUnDoneTask>;

export const UNDONE_TASK_WITH_DEADLINE = "UnDoneTaskWithDeadline";
export const UnDoneTaskWithDeadline = z.object({
  kind: z.literal(UNDONE_TASK_WITH_DEADLINE),
  id: TaskId,
  name: z.string(),
  dueDate: z.date(),
});
export type UnDoneTaskWithDeadline = z.infer<typeof UnDoneTaskWithDeadline>;

export const DONE_TASK = "DoneTask";
export const DoneTask = z.object({
  kind: z.literal(DONE_TASK),
  id: TaskId,
  name: z.string(),
  dueDate: z.date(),
});
export type DoneTask = z.infer<typeof DoneTask>;

export type Task = UnDoneTask | DoneTask;
export const TASK =
  POSTPONABLE_UNDONE_TASK || UNDONE_TASK_WITH_DEADLINE || DONE_TASK;

export type UnDoneTask = PostPonableUnDoneTask | UnDoneTaskWithDeadline;
export const UNDONE_TASK = POSTPONABLE_UNDONE_TASK || UNDONE_TASK_WITH_DEADLINE;
```

### æ‰€æ„Ÿ

- ä»Šå›ã¯ zod ã‚’ä½¿ç”¨ã—ã¦ãƒ‰ãƒ¡ã‚¤ãƒ³çŸ¥è­˜ã‚’è¡¨ç¾ã—ã¦ã¿ã¾ã—ãŸã€‚ã‚·ãƒ³ãƒ—ãƒ«ãªã‚³ãƒ¼ãƒ‰ã§é«˜ã„è¡¨ç¾åŠ›ã‚’æŒã¡ã¾ã™ãŒã€ãƒ‰ãƒ¡ã‚¤ãƒ³å±¤ãŒæµè¡Œã‚Šå»ƒã‚Šã®æ¿€ã—ã„ã‚¹ã‚­ãƒ¼ãƒãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã«ä¾å­˜ã™ã‚‹å ´åˆã¯ã€å¾Œæ—¥ã®æ”¹ä¿®ã‚³ã‚¹ãƒˆã‚’å—ã‘å…¥ã‚Œã‚‹å¿…è¦ãŒã‚ã‚‹ã®ã§è³›å¦ä¸¡è«–ã‚ã‚Šãã†ã§ã™ã­ã€‚
- ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼ã‹ã‚‰å‡ºåŠ›ã•ã‚ŒãŸã‚¤ãƒ™ãƒ³ãƒˆã¯éå»å½¢ã«ãªã‚‹ã¨ã€ŒDomain Modeling Made Functionalã€ã«è¨˜è¼‰ã•ã‚Œã¦ã„ãŸã®ã§ã™ãŒã€ãƒ‰ãƒ¡ã‚¤ãƒ³çŸ¥è­˜ã‚’ã†ã¾ãè¡¨ç¾ã§ããªã‹ã£ãŸã®ã§ä»Šå›ã¯éå»å½¢ã«ã—ã¦ã„ã¾ã›ã‚“ã€‚
  - ä¾‹ãˆã°ã€postpone ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼ã®å‡ºåŠ›ã‚¤ãƒ™ãƒ³ãƒˆã¯ postponedTask ã¨è¡¨ç¾ã™ã‚‹ã¹ãã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ãŒã€postponedTask ã¨ã„ã†åç§°ã‹ã‚‰ã¯å»¶æœŸå›æ•°ãŒ 2 å›ä»¥ä¸‹ or 3 å›ã®ã©ã¡ã‚‰ã‹ä¼ã‚ã‚Šã¾ã›ã‚“ã€‚ãŸã ã€æ¬¡ã®ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼ã«æ¸¡ã™å ´åˆã«ä¸‹è¨˜ã®ã‚ˆã†ã«å‹ã‚’å¤‰æ›ã™ã‚Œã°è‰¯ã„ã®ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ã€‚

```
// postponedTaskã®å»¶æœŸå›æ•°ã‚’åˆ¤å®šã™ã‚‹
if (postponedTask.postPoneCount <= 2) {
    return PostPonableUnDoneTask.parse({
      kind: "PostPonableUnDoneTask",
      id: TaskId.parse(postponedTask.id),
      name: postponedTask.name,
      dueDate: postponedTask.dueDate,
      postPoneCount: postponedTask.postPoneCount,
    });
} else {
    return UnDoneTaskWithDeadline.parse({
      kind: "UnDoneTaskWithDeadline",
      id: TaskId.parse(postponedTask.id),
      name: postponedTask.name
      dueDate: postponedTask.dueDate
    });
}
```

- UnDoneTaskWithDeadline ã¨ã„ã†å»¶æœŸå›æ•°ãŒ 3 å›ã«ãªã£ã¦å»¶æœŸã§ããªããªã£ãŸã‚¿ã‚¹ã‚¯ã‚’è¡¨ç¾ã™ã‚‹éš›ã«ã€ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã¨ã—ã¦ postPoneCount ã‚’æŒã¤ã¹ãã‹ã©ã†ã‹æ‚©ã¿ã¾ã—ãŸã€‚æŒ¯ã‚‹èˆã„ãŒç•°ãªã‚‹çŠ¶æ…‹ã‚’å‹ã§è¡¨ç¾ã™ã‚‹ã®ã§ã‚ã‚Œã°ã€å‹ã®åç§°ã§ä¼ã‚ã‚‹ã®ã§ã€ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã¨ã—ã¦æŒãŸã›ãªã„ã“ã¨ã«ã—ã¾ã—ãŸã€‚ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ãŒå­˜åœ¨ã—ãªã„ã®ã§ã€UnDoneTaskWithDeadline ã® postPoneCount ãŒ 4 ä»¥ä¸Šã«ãªã‚‹ã¨ã„ã£ãŸã“ã¨ã¯èµ·ã“ã‚Šã¾ã›ã‚“ã€‚
- æŒ¯ã‚‹èˆã„ãŒåŒã˜ã ãŒãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ãŒåŒä¸€ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒå­˜åœ¨ã—ãŸå ´åˆã€åˆ¤å®šå‡¦ç†ãŒå¿…è¦ã§ã™ï¼ˆä¾‹ãˆã° UnDoneTaskWithDeadline ã¨ DoneTaskï¼‰ã€‚ã“ã‚Œã¯å‰å›ã®è¨˜äº‹ã§ã‚‚è¨˜è¼‰ã—ã¾ã—ãŸãŒã€discriminated union ã§è¡¨ç¾ã™ã‚‹ã“ã¨ã§è§£æ±ºã—ã¦ã„ã¾ã™ã€‚

```
export const UnDoneTaskWithDeadline = z.object({
  kind: z.literal(UNDONE_TASK_WITH_DEADLINE), // kindãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã§åˆ¤å®šã§ãã‚‹
  id: TaskId,
  name: z.string(),
  dueDate: z.date(),
});
```

- ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼ã®ç²’åº¦, ãƒ‡ãƒ¼ã‚¿æ§‹é€ ã®åç§°ã«ã¤ã„ã¦ã¯ãƒ‰ãƒ¡ã‚¤ãƒ³ã®æ–‡æ›¸åŒ–æ™‚ç‚¹ã¨ã‚ºãƒ¬ã‚‹ã“ã¨ãŒã‚ã‚Šã€æ‚©ã¿ãªãŒã‚‰å®Ÿè£…ã—ã¾ã—ãŸã€‚ã„ã¾ã„ã¡ã¾ã æ„Ÿè¦šãŒæ´ã‚ã¦ã„ã¾ã›ã‚“ã€‚

## ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³å±¤

ä¾‹ã¨ã—ã¦ postponeUseCase ã‚’ç´¹ä»‹ã—ã¾ã™ã€‚

```
import {
  POSTPONABLE_UNDONE_TASK,
  PostPonableUnDoneTask,
  PostPoneTaskRepository,
  TaskId,
  postpone,
} from "../../domain/task/task";
import { FetchTaskQuery } from "../../infra/task/query/fetchTaskQuery";
import { TaskDto } from "./taskDto";

export const postPoneTaskUseCase =
  (
    fetchTaskQuery: FetchTaskQuery,
    postPoneTaskRepository: PostPoneTaskRepository
  ) =>
  async (taskId: TaskId) => {
    const taskDto: TaskDto = await fetchTaskQuery(taskId);

    if (taskDto.isDone) {
      throw new Error("task is already done");
    }

    const postPonableUnDoneTask = PostPonableUnDoneTask.parse({
      kind: POSTPONABLE_UNDONE_TASK,
      id: TaskId.parse(taskDto.id),
      name: taskDto.name,
      dueDate: taskDto.dueDate,
      postPoneCount: taskDto.postPoneCount,
    });

    const result = await postPoneTaskRepository(
      postpone(postPonableUnDoneTask)
    );

    return await fetchTaskQuery(result.id);
  };
```

### æ‰€æ„Ÿ

- UseCase å±¤ã¯ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼ã‚’å‘¼ã³å‡ºã™ã ã‘ã®å­˜åœ¨ã¨ã—ã¦æ‰±ã£ã¦ã„ã¾ã™ã€‚
- ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼ã¯ç´”ç²‹ã§å‰å¾Œã« Infra å±¤ã®ã‚³ãƒ¼ãƒ‰ã‚’å‘¼ã³å‡ºã™ã“ã¨ã§ã€ç«¯ã«ä¾å­˜ã‚’æŠ¼ã—ã‚„ã£ã¦ã„ã¾ã™ã€‚
- é–¢æ•°å‹ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°çš„ã«ã¯å°ã•ã„é–¢æ•°ã‚’åˆæˆã—ã¦ã„ãã®ã§ã€taskId ã‹ã‚‰ TaskDto ã‚’å–å¾—ã—ã¦ãƒ‰ãƒ¡ã‚¤ãƒ³ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã« parse ã™ã‚‹å‡¦ç†ã‚’åˆ¥ã®é–¢æ•°ã«åˆ‡ã‚Šå‡ºã—ãŸã»ã†ãŒã„ã„ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ã€‚

## ã‚¤ãƒ³ãƒ•ãƒ©ã‚¹ãƒˆãƒ©ã‚¯ãƒãƒ£å±¤

ä¾‹ã¨ã—ã¦ postPoneTaskRepository ã‚’ç´¹ä»‹ã—ã¾ã™ã€‚

```
import { PrismaClient } from "@prisma/client";
import {
  POSTPONABLE_UNDONE_TASK,
  PostPonableUnDoneTask,
  UNDONE_TASK_WITH_DEADLINE,
  UnDoneTask,
  UnDoneTaskWithDeadline,
  POSTPONE_COUNT_LIMIT,
} from "../../../domain/task/task";

export const postPoneTaskRepository =
  (prisma: PrismaClient) => async (unDoneTask: UnDoneTask) => {
    try {
      if (unDoneTask.kind === POSTPONABLE_UNDONE_TASK) {
        const task = await prisma.task.update({
          where: { id: unDoneTask.id },
          data: {
            dueDate: unDoneTask.dueDate,
            postPoneCount: unDoneTask.postPoneCount,
          },
        });

        return PostPonableUnDoneTask.parse({
          kind: POSTPONABLE_UNDONE_TASK,
          id: task.id,
          name: task.name,
          dueDate: task.dueDate,
          postPoneCount: task.postPoneCount,
        });
      } else {
        const task = await prisma.task.update({
          where: { id: unDoneTask.id },
          data: {
            dueDate: unDoneTask.dueDate,
            postPoneCount: POSTPONE_COUNT_LIMIT,
          },
        });

        return UnDoneTaskWithDeadline.parse({
          kind: UNDONE_TASK_WITH_DEADLINE,
          id: task.id,
          name: task.name,
          dueDate: task.dueDate,
          postPoneCount: task.postPoneCount,
        });
      }
    } catch (error: any) {
      throw new Error(error);
    }
  };
```

### æ‰€æ„Ÿ

- ãƒ‰ãƒ¡ã‚¤ãƒ³ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’å—ã‘å–ã£ã¦ã€ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã«æ°¸ç¶šåŒ–ã™ã‚‹éš›ã«å–å¾—ã—ãŸãƒ‡ãƒ¼ã‚¿ã‚’ãƒ‰ãƒ¡ã‚¤ãƒ³ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«å¤‰æ›ã—ã¦è¿”ã—ã¦ã„ã¾ã™ã€‚
- unDoneTask.kind === UNDONE_TASK_WITH_DEADLINE ã®å ´åˆã¯ postPoneCount ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã‚’æŒã£ã¦ã„ãªã„ã®ã§ã€æ°¸ç¶šåŒ–ã™ã‚‹éš›ã«ãƒ‰ãƒ¡ã‚¤ãƒ³å±¤ã® POSTPONE_COUNT_LIMIT ã‚’å‚ç…§ã—ã¦ã„ã¾ã™ã€‚ãŸã ã€POSTPONE_COUNT_LIMIT ã¯ãƒ‰ãƒ¡ã‚¤ãƒ³å±¤ã§ã¯ä½¿ç”¨ã—ã¦ã„ãªã„ã‚“ã§ã™ã‚ˆã­...ã€‚ã‚¤ãƒ³ãƒ•ãƒ©å±¤ã«ãƒ‰ãƒ¡ã‚¤ãƒ³çŸ¥è­˜ãŒæ¼ã‚Œã¦ã„ã‚‹ã‚ã‘ã§ã¯ãªã•ãã†ã§ã™ãŒã¡ã‚‡ã£ã¨ãƒ¢ãƒ¤ã£ã¦ã¾ã™ã€‚ã¨ã¯ã„ãˆã€çŠ¶æ…‹ã‚’å‹ã§è¡¨ç¾ã™ã‚‹ã‚¢ãƒ—ãƒ­ãƒ¼ãƒã§ã¯è‡´ã—æ–¹ãªã„ã®ã§ã—ã‚‡ã†ã‹ã€‚

## ãƒ—ãƒ¬ã‚¼ãƒ³ãƒ†ãƒ¼ã‚·ãƒ§ãƒ³å±¤

ä¾‹ã¨ã—ã¦ postPoneTaskController ã‚’ç´¹ä»‹ã—ã¾ã™ã€‚

```
import { Request, Response } from "express";
import { PrismaClient } from "@prisma/client";
import { TaskId } from "../../domain/task/task";
import { postPoneTaskUseCase } from "../../application/task/postPoneTaskUseCase";
import { fetchTaskQuery } from "../../infra/task/query/fetchTaskQuery";
import { postPoneTaskRepository } from "../../infra/task/repository/postPoneTaskRepository";

export type RequestParams = {
  taskId: string;
};

export const postPoneTaskController = async (
  req: Request<RequestParams, {}, {}>,
  res: Response
) => {
  const prisma = new PrismaClient();

  const result = await postPoneTaskUseCase(
    fetchTaskQuery(prisma),
    postPoneTaskRepository(prisma)
  )(TaskId.parse(req.params.taskId));

  res.status(200).json({ result });
};
```

### æ‰€æ„Ÿ

- ãƒˆãƒƒãƒ—ãƒ¬ãƒ™ãƒ«ã§ä¾å­˜é–¢ä¿‚ã‚’è§£æ±ºã™ã‚‹å ´æ‰€ã§ã™ã­

# ãã®ä»–

## DTO ã‚’ ãƒ‰ãƒ¡ã‚¤ãƒ³ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ ã«å¤‰æ›ã™ã‚‹å‡¦ç†ã®è¤‡é›‘ã•ã¯å¢—ã™

ä¸‹è¨˜ã®ã‚ˆã†ã«ã‚¯ã‚¨ãƒªã‚µãƒ¼ãƒ“ã‚¹ã‹ã‚‰å–å¾—ã—ãŸ DTO ã‚’ãƒ‰ãƒ¡ã‚¤ãƒ³ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«å¤‰æ›ã—ã¦ã€ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼ã«æ¸¡ã—ã¦ã„ã¾ã™ã€‚
ç¾æ™‚ç‚¹ã§ã¯ toDomain ãƒ¡ã‚½ãƒƒãƒ‰ã®å‡¦ç†ã¯ç°¡å˜ã§ã™ãŒã€è¦ä»¶ãŒå¢—ãˆã‚‹ã“ã¨ã«ã‚ˆã£ã¦è¤‡é›‘ã«ãªã‚‹ã“ã¨ãŒäºˆæƒ³ã•ã‚Œã¾ã™ã€‚æŒ¯ã‚‹èˆã„ã«ã‚ˆã£ã¦å‹ã‚’åˆ†ã‘ã¦è¤‡é›‘ã•ã«å¯¾å‡¦ã™ã‚‹ã‚¢ãƒ—ãƒ­ãƒ¼ãƒã¯ãƒ‰ãƒ¡ã‚¤ãƒ³å±¤ã«é–¢ã—ã¦ã¯ãã®é€šã‚Šãªã®ã§ã™ãŒã€åŸºæœ¬çš„ãªãƒ‡ãƒ¼ã‚¿å‹ã‹ã‚‰ãƒ‰ãƒ¡ã‚¤ãƒ³ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¸ã®å¤‰æ›å‡¦ç†ã«è¤‡é›‘ã•ãŒç§»å‹•ã™ã‚‹ã¨ã„ã†å´é¢ãŒã‚ã‚‹ã®ã§ã¯ãªã„ã§ã—ã‚‡ã†ã‹ã€‚ã‚‚ã¡ã‚ã‚“ã€ãã‚Œã§ã‚‚å¾—ã‚‰ã‚Œã‚‹æ©æµã®æ–¹ãŒå¤§ãã„ã¨æ€ã„ã¾ã™ã€‚

```
export const completeTaskUseCase =
  (
    fetchTaskQuery: FetchTaskQuery,
    completeTaskRepository: CompleteTaskRepository
  ) =>
  async (taskId: TaskId) => {
    try {
      const taskDto: TaskDto = await fetchTaskQuery(taskId);
      const task = toDomain(taskDto);
      if (task.kind === DONE_TASK) return taskDto;

      const result = await completeTaskRepository(complete(task));
      return await fetchTaskQuery(result.id);
    } catch (error: any) {
      throw new Error(error);
    }
  };
```

```
export type TaskDto = {
  id: string;
  name: string;
  dueDate: Date;
  postPoneCount: number;
  isDone: boolean;
  createdAt: Date;
  updatedAt: Date;
};

export const toDomain = (task: TaskDto): Task => {
  if (task.isDone === false) {
    if (task.postPoneCount <= 2) {
      return {
        kind: POSTPONABLE_UNDONE_TASK,
        id: TaskId.parse(task.id),
        name: task.name,
        dueDate: task.dueDate,
        postPoneCount: task.postPoneCount,
      };
    } else {
      return {
        kind: UNDONE_TASK_WITH_DEADLINE,
        id: TaskId.parse(task.id),
        name: task.name,
        dueDate: task.dueDate,
      };
    }
  } else {
    return {
      kind: DONE_TASK,
      id: TaskId.parse(task.id),
      name: task.name,
      dueDate: task.dueDate,
    };
  }
};
```

## zod ã¯å®Ÿè¡Œæ™‚ã«å€¤ã‚’æ¤œè¨¼ã™ã‚‹ã®ã§ã€å®Ÿè¡Œå‰ã«ã‚¨ãƒ©ãƒ¼ã‚’æ¤œçŸ¥ã—ã¥ã‚‰ã„

å®Ÿè¡Œå‰ã«ã‚¨ãƒ©ãƒ¼ã‚’æ¤œçŸ¥ã§ããªãã¦ã€é–‹ç™ºã—ã¥ã‚‰ã„ã§ã™ã€‚ã¾ã‚ã€z.infer ã‚’ä½¿ç”¨ã™ã‚Œã° PostPonableUnDoneTask ã®å‹ã‚’å–å¾—ã§ãã‚‹ã®ã§ã™ãŒã€parse ã«ç›´æ¥ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’æ¸¡ã™éš›ã«ã†ã¾ãæ¤œçŸ¥ã§ããªã„ã®ãŒå¾®å¦™ã ãªã¨æ€ã„ã¾ã—ãŸï¼ˆã‚‚ã£ã¨è‰¯ã„æ–¹æ³•ãŒã‚ã‚Œã°æ•™ãˆã¦ãã ã•ã„ï¼‰

```
export const POSTPONABLE_UNDONE_TASK = "PostPonableUnDoneTask";
export const PostPonableUnDoneTask = z.object({
  kind: z.literal(POSTPONABLE_UNDONE_TASK),
  id: TaskId,
  name: z.string(),
  dueDate: z.date(),
  postPoneCount: z.number().min(0).max(2),
});
export type PostPonableUnDoneTask = z.infer<typeof PostPonableUnDoneTask>;

const postPonableUnDoneTask = PostPonableUnDoneTask.parse({
    kind: "PostPonableUnDoneTask", // kindãŒå­˜åœ¨ã—ãªã„å ´åˆã‚‚æ€’ã‚‰ã‚Œãªãã¦é–‹ç™ºã—ã¥ã‚‰ã„
    id: command.id,
    name: command.name,
    dueDate: command.dueDate,
    postPoneCount: command.postPoneCount,
});
```

## è²¬å‹™ã”ã¨ã«ãƒ•ã‚¡ã‚¤ãƒ«ã‚’åˆ†ã‘ã‚‹ã¨ã‚¹ãƒƒã‚­ãƒªã™ã‚‹

ä»Šå›ãƒ¡ã‚½ãƒƒãƒ‰ã”ã¨ã«ãƒ•ã‚¡ã‚¤ãƒ«ã‚’åˆ†ã‘ã¦ã„ã¾ã™ã€‚ãƒ¡ã‚½ãƒƒãƒ‰å˜ä½ã§è²¬å‹™ãŒåˆ†ã‹ã‚Œã¦ã„ã‚‹ã¨æ‰ãˆã‚‹ã¨ã€1 ãƒ•ã‚¡ã‚¤ãƒ«ã®ä¸­èº«ãŒè‚¥å¤§åŒ–ã—ãªã„ã®ã§å€‹äººçš„ã«ã¯å¥½ã¿ã§ã™ã€‚

# ã¾ã¨ã‚

ã€ŒDomain Modeling Made Functionalã€ã‚’å‚è€ƒã«ã€æŒ¯ã‚‹èˆã„ã«å¿œã˜ã¦å‹ã‚’åˆ†ã‘ã‚‹ã“ã¨ã§è¤‡é›‘ã•ã«å¯¾å‡¦ã™ã‚‹æ–¹æ³•ã‚’å®Ÿè·µã—ã¦ã¿ã¾ã—ãŸã€‚ç‰¹ã« I/O éƒ¨åˆ†ã®å®Ÿè£…ã«ã¤ã„ã¦æ„Ÿè§¦ã‚’å¾—ã‚‰ã‚Œã‚‹ã“ã¨ãŒã§ãã¦ã‚ˆã‹ã£ãŸã§ã™ã€‚è¦ä»¶è‡ªä½“ã¯ã‚·ãƒ³ãƒ—ãƒ«ã§ã™ãŒã€å®Ÿéš›ã«å®Ÿè£…ã—ã¦ã¿ã‚‹ã¨ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼ã‚„ãƒ‡ãƒ¼ã‚¿æ§‹é€ ã‚’ã©ã®ã‚ˆã†ã«çµ„ã¿ç«‹ã¦ã‚Œã°è‰¯ã„ã‹è¿·ã„ã¾ã—ãŸã€‚ã“ã®ã‚¢ãƒ—ãƒ­ãƒ¼ãƒè‡ªä½“ã¯å€‹äººçš„ã«å¥½ã¿ãªã®ã§ã€ã‚‚ã£ã¨çµŒé¨“ã‚’ç©ã‚“ã§ã„ããŸã„ã¨æ€ã„ã¾ã™ã€‚

# å‚è€ƒæƒ…å ±

ä»Šå›å‚è€ƒã«ã—ãŸæƒ…å ±ã‚’ã¾ã¨ã‚ã¦ãŠãã¾ã™ã€‚ã¨ã¦ã‚‚å‚è€ƒã«ãªã‚Šã¾ã—ãŸã€‚ã‚ã‚ŠãŒã¨ã†ã”ã–ã„ã¾ã™ã€‚
https://www.amazon.co.jp/-/en/Scott-Wlaschin/dp/1680502549
https://github.com/swlaschin/DomainModelingMadeFunctional
https://github.com/kawasima/dmmf-ts
https://github.com/kawasima/revisiting-domain-model
https://speakerdeck.com/naoya/typescript-niyoru-graphql-batukuendokai-fa
https://speakerdeck.com/naoya/typescript-niyoru-graphql-batukuendokai-fa-75b3dab7-90a8-4169-a4dc-d1e7410b9dbd

# ãŠã‚ã‚Šã«

æ˜æ—¥ã¯ãƒªã‚µãƒ¼ãƒã‚¨ãƒ³ã‚¸ãƒ‹ã‚¢ã® @YotaroMatsui ã•ã‚“ã®è¨˜äº‹ã§ã™ã€‚ãŠæ¥½ã—ã¿ã«ï¼
